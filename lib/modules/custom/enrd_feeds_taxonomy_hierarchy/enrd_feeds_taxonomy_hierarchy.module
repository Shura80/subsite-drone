<?php

/**
 * @file
 * Provide a feed mapper for importing hierarchical taxonomy terms.
 */

// Default hierarchy separator.
define('ENRD_FEEDS_TAXONOMY_HIERARCHY_DEFAULT_HIERARCHY_SEPARATOR', '>');

// Default save term lineage.
define('ENRD_FEEDS_TAXONOMY_HIERARCHY_DEFAULT_SAVE_TERM_LINEAGE', 0);

/**
 * Implements hook_feeds_processor_targets_alter().
 */
function enrd_feeds_taxonomy_hierarchy_feeds_processor_targets_alter(&$targets, $entity_type, $bundle_name) {
  foreach (field_info_instances($entity_type, $bundle_name) as $name => $instance) {
    $field_info = field_info_field($name);
    if ($field_info['type'] == 'taxonomy_term_reference') {
      $targets[$name . '_hierarchical'] = array(
        'name' => t('@name: hierarchical by term name', array('@name' => $instance['label'])),
        'callback' => '_enrd_feeds_taxonomy_hierarchy_feeds_set_target',
        'description' => t('The @label field of the entity.', array('@label' => $instance['label'])),
        'form_callback' => '_enrd_feeds_taxonomy_hierarchy_form_callback',
        'validate_callback' => '_enrd_feeds_taxonomy_hierarchy_validate_callback',
        'summary_callback' => '_enrd_feeds_taxonomy_hierarchy_summary_callback',
      );
    }
  }
}

/**
 * Settings form callback.
 */
function _enrd_feeds_taxonomy_hierarchy_form_callback($mapping, $target, $form, $form_state) {

  $settings = array();

  // Merge custom with default map settings.
  $mapping = _enrd_feeds_taxonomy_hierarchy_get_map_settings($mapping);

  // Hierarchy separator textfield.
  $settings['hierarchy_separator'] = array(
    '#type' => 'textfield',
    '#title' => t('Hierarchy separator'),
    '#description' => t('%s will be substituted for a space, %t for a tab and %n for a newline.'),
    '#default_value' => $mapping['hierarchy_separator'],
  );

  // Save term lineage checkbox.
  $settings['save_term_lineage'] = array(
    '#type' => 'checkbox',
    '#title' => t('Save term lineage'),
    '#description' => t("Save the deepest term and all parent terms as the entity's value."),
    '#default_value' => $mapping['save_term_lineage'],
  );

  return $settings;
}

/**
 * Summary callback.
 */
function _enrd_feeds_taxonomy_hierarchy_summary_callback($mapping, $target, $form, $form_state) {
  // Merge custom with default map settings.
  $mapping = _enrd_feeds_taxonomy_hierarchy_get_map_settings($mapping);

  // Define summary list items.
  $items = array(
    t('Hierarchy separator: %hierarchy_separator', array('%hierarchy_separator' => $mapping['hierarchy_separator'])),
    t('Save term lineage: %save_term_lineage', array('%save_term_lineage' => $mapping['save_term_lineage'] ? t('Yes') : t('No'))),
  );

  return theme('item_list', array('items' => $items));
}

/**
 * Callback for mapping. Here is where the actual mapping happens.
 */
function _enrd_feeds_taxonomy_hierarchy_feeds_set_target($source, $entity, $target, $term_names = NULL, array $mapping = array()) {

  // Return if no term names are defined.
  if (empty($term_names)) {
    return;
  }
  // If a string is supplied, create array.
  elseif (is_string($term_names)) {
    $term_names = array($term_names);
  }

  // Define shared object so other functions can also easily access them.
  if (!$shared = &drupal_static('ENRD_FEEDS_TAXONOMY_HIERARCHY_SHARED_OBJECT_IDENTIFIER')) {
    $shared = new stdClass();
  }

  // Merge custom with default map settings.
  $shared->mapping = _enrd_feeds_taxonomy_hierarchy_get_map_settings($mapping);

  // Get field name by stripping '_hierarchical' postfix from target.
  $shared->field_name = $field_name = drupal_substr($target, 0, -13);

  // This function is called for every entity being imported, so cache as much
  // as possible to prevent duplicate queries.
  _enrd_feeds_taxonomy_hierarchy_set_caches();

  // Use a flat array that holds term id's so we can easily check if a field
  // already has a certain term's id as value.
  $term_ids = array();

  // By default updating entities overwrites previous values, so this module
  // Does Not support that either, but leave this code for possible later use
  // In case Feeds is updating entities, also use existing field values.
  if (FALSE && isset($entity->$field_name)) {
    // Get existing field values.
    $field_values = $entity->{$field_name}[LANGUAGE_NONE];

    // Iterate through id's of existing field values.
    foreach ($field_values as $field_value) {
      // Copy field value to our flat array.
      $term_ids[] = $field_value['tid'];
    }
  }
  // In case Feeds is replacing entities, we can start with an empty array.
  else {
    $field_values = array();
  }

  // If the allowed amount of values for this entity field is set to unlimited.
  if ($shared->cache->{$field_name}->field_info['cardinality'] == -1) {
    // Set a very high maximum.
    $max_allowed_values = 999999;
  }
  else {
    // Subtract amount of existing values from amount of allowed values so we
    // know how many more values we are allowed to add.
    $max_allowed_values = $shared->cache->{$field_name}->field_info['cardinality'] - count($term_ids);
  }

  // Escape hierarchy separator for usage in regular expression and substitute
  // characters for their regular expression counterparts.
  $preg_hierarchy_separator = str_replace(array('%s', '%t', '%n'), array(
    '\s+',
    '\t+',
    '[\r\n]+',
  ), preg_quote($shared->mapping['hierarchy_separator']));

  // Iterate through names of to be added terms.
  foreach ($term_names as $term_name) {
    // Break loop if field's maximum amount of allowed values has been reached.
    if ($max_allowed_values == 0) {
      break;
    }

    // If term_name is actually a FeedsTermElement.
    if ($term_name instanceof FeedsTermElement) {
      // Add term id to field values.
      _enrd_feeds_taxonomy_hierarchy_add_term_id_to_field_values($term_name->tid, $term_ids, $field_values, $max_allowed_values);
    }
    else {
      // Remove white spaces around term names, split string into an array and
      // remove empty terms.
      $hierarchical_term_names = array_filter(preg_split('#\s*' . $preg_hierarchy_separator . '\s*#', trim($term_name)));

      // Get array of id's of hierarchical terms.
      _enrd_feeds_taxonomy_hierarchy_handle_hierarchical_term_names($hierarchical_term_names, $term_ids, $field_values, $max_allowed_values);
    }
  }

  // Set entity's field values.
  $entity->{$field_name}[LANGUAGE_NONE] = $field_values;
}

/**
 * Get array with custom map settings or default values.
 */
function _enrd_feeds_taxonomy_hierarchy_get_map_settings($mapping) {
  // Merge custom map settings with default values.
  return $mapping += array(
    'hierarchy_separator' => ENRD_FEEDS_TAXONOMY_HIERARCHY_DEFAULT_HIERARCHY_SEPARATOR,
    'save_term_lineage' => ENRD_FEEDS_TAXONOMY_HIERARCHY_DEFAULT_SAVE_TERM_LINEAGE,
  );
}

/**
 * Set caches.
 */
function _enrd_feeds_taxonomy_hierarchy_set_caches() {
  // Get static shared object.
  $shared = &drupal_static('ENRD_FEEDS_TAXONOMY_HIERARCHY_SHARED_OBJECT_IDENTIFIER');

  // Locally define shared variable for better readability.
  $field_name = $shared->field_name;

  // Set some caches.
  if (!isset($shared->cache->{$field_name}->field_info)) {
    // Cache field info.
    $shared->cache->{$field_name}->field_info = field_info_field($field_name);

    // Cache allowed values for this field.
    $shared->cache->{$field_name}->taxonomy_allowed_values = taxonomy_allowed_values($shared->cache->{$field_name}->field_info);

    // Cache vocabulary id's for this field.
    $shared->cache->{$field_name}->vocabulary_ids = array();

    // Allowed values are stored by vocabulary, so we can retrieve vocabulary
    // id's by iterating through this array. Though an entity's taxonomy
    // reference field normally is only referencing to terms from a single
    // vocabulary, we iterate through all vocabularies like Feeds' original
    // taxonomy mapper taxonomy_feeds_set_target() and taxonomy_allowed_values()
    // do.
    foreach ($shared->cache->{$field_name}->field_info['settings']['allowed_values'] as $tree) {
      // Drupal used to use vocabulary id's but uses machine names nowadays, see
      // http://drupal.org/node/881530.
      if (isset($tree['vocabulary']) && !empty($tree['vocabulary'])) {
        // Load vocabulary by machine name.
        $vocabulary = taxonomy_vocabulary_machine_name_load($tree['vocabulary']);

        // Add vocabulary's id.
        $shared->cache->{$field_name}->vocabulary_ids[] = (int) $vocabulary->vid;
      }
      elseif (isset($tree['vid']) && !empty($tree['vid'])) {
        // Add vocabulary's id.
        $shared->cache->{$field_name}->vocabulary_ids[] = (int) $tree['vid'];
      }
    }
  }
}

/**
 * Handle hierarchical terms by name.
 */
function _enrd_feeds_taxonomy_hierarchy_handle_hierarchical_term_names($term_names, &$term_ids, &$field_values, &$max_allowed_values) {
  // Get static shared object.
  $shared = &drupal_static('ENRD_FEEDS_TAXONOMY_HIERARCHY_SHARED_OBJECT_IDENTIFIER');

  // Locally define shared variable for better readability.
  $field_name = $shared->field_name;

  // Term's parent id, starting with 0 for the vocabulary's root.
  $parent_id = 0;

  // Iterate through all hierarchical terms by name.
  foreach ($term_names as $i => $term_name) {
    // Set term id to null so we can check if a term has been found or created.
    $term_id = NULL;

    // Break loop if field's maximum amount of allowed values has been reached.
    if ($max_allowed_values == 0) {
      break;
    }

    // Try to get the id of an existing term.
    if ($term_id = _enrd_feeds_taxonomy_hierarchy_get_term_id($parent_id, $term_name)) {
      // Return if term's id is NOT an allowed value.
      if (!isset($shared->cache->{$field_name}->taxonomy_allowed_values[$term_id])) {
        return;
      }

      // Set parent id.
      $parent_id = $term_id;
    }

    // If a term has been found or created, check whether the term lineage needs
    // to be saved OR the term is the deepest term.
    if ($term_id && ($shared->mapping['save_term_lineage'] || count($term_names) == $i + 1)) {
      // Add term id to field values.
      _enrd_feeds_taxonomy_hierarchy_add_term_id_to_field_values($term_id, $term_ids, $field_values, $max_allowed_values);
    }
  }
}

/**
 * Add term id to field values.
 */
function _enrd_feeds_taxonomy_hierarchy_add_term_id_to_field_values($term_id, &$term_ids, &$field_values, &$max_allowed_values) {
  // If term id is not yet in term id array.
  if (!in_array($term_id, $term_ids)) {
    // Add term id array with term id's.
    $term_ids[] = $term_id;

    // Add term id to field values.
    $field_values[] = array('tid' => $term_id);

    // Increment maximum allowed values.
    --$max_allowed_values;
  }
}

/**
 * Get term id by the term's parent id and term name.
 */
function _enrd_feeds_taxonomy_hierarchy_get_term_id($parent_id, $term_name) {
  // Get static shared object.
  $shared = &drupal_static('ENRD_FEEDS_TAXONOMY_HIERARCHY_SHARED_OBJECT_IDENTIFIER');

  // Locally define shared variable for better readability.
  $field_name = $shared->field_name;
  $vocabulary_id = $shared->cache->{$field_name}->vocabulary_ids[0];

  // If this term has not been looked up before.
  if (!isset($shared->cache->queried_term_ids[$vocabulary_id][$parent_id][$term_name])) {
    // Build and execute query to find term id.
    $query = db_select('taxonomy_term_data', 'td');
    $query->join('taxonomy_term_hierarchy', 'th', 'td.tid=th.tid');

    $result = $query
      ->fields('td', array('tid'))
      ->condition('vid', $vocabulary_id)
      ->condition('parent', $parent_id)
      ->condition('name', $term_name)
      ->execute()
      ->fetchObject();

    // Cache the query result, a term id or false.
    $shared->cache->queried_term_ids[$vocabulary_id][$parent_id][$term_name] = isset($result->tid) ? $result->tid : FALSE;
  }

  // Return term id or false.
  return $shared->cache->queried_term_ids[$vocabulary_id][$parent_id][$term_name];
}
